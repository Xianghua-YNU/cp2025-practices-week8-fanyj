# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和
```python
import numpy as np

def sum_up(N):
    """从小到大求和"""
    s = 0.0
    for n in range(1, N+1):
        s += 1.0/n
    return s

def sum_down(N):
    """从大到小求和""" 
    s = 0.0
    for n in range(N, 0, -1):
        s += 1.0/n
    return s

def relative_diff(a, b):
    """计算相对差异"""
    return abs(a - b) / ((a + b)/2)
```
### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

| N       | S_up       | S_down     | 相对差异    |
|---------|------------|------------|-------------|
| 10      | 2.928968   | 2.928968   | 0.0         |
| 100     | 5.187377   | 5.187378   | 1.93e-7     |
| 1000    | 7.485470   | 7.485472   | 2.67e-7     |
| 10^4    | 9.787606   | 9.787613   | 7.16e-7     |
| 10^5    | 12.090146  | 12.090156  | 8.27e-7     |
| 10^6    | 14.392727  | 14.392726  | 6.95e-8     |
| 10^7    | 16.695311  | 16.695311  | 0.0         |
| 10^8    | 18.997896  | 18.997896  | 0.0         |
### 4.2 误差分析图
![误差对比图](data:image/png;base64,...)

## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   1. **小N值阶段**：差异可忽略，舍入误差累积不明显
   2. **中等N值阶段**：正向求和的小数部分丢失严重，差异显著
   3. **大N值阶段**：部分和足够大，使新加项的影响可忽略

2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）
   - （结合浮点数表示方式解释）
- **正向求和**：随着部分和增大，新加的1/n的有效数字逐渐丢失
- **反向求和**：始终保持大数加小数，有效数字保留更完整
- **极端情况**：当部分和远大于新加项时，两种方法都失效
### 5.2 误差来源分析
1. 浮点数表示精度限制
2. 加法运算中的舍入
3. 求和顺序的影响
- 双精度浮点数的精度限制约为1e-16
- 调和级数和对数增长，达到1e16需要约e^1e16项
- 实际计算中早在此之前就会遇到精度问题
## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）
1. 反向求和（从大到小）在大多数情况下更精确
2. 求和顺序对结果的影响呈现非线性特征
3. 当N极大时，两种方法都会失效，需要更高精度算法
## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？
 因为始终保持较大的数相加，减少小数有效数字丢失。
2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？
   - 中等规模：反向求和
   - 大规模：分块求和（先求和小区间，再汇总）
3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
   - Kahan求和算法补偿舍入误差
   - 使用更高精度的数据类型（如四精度）
## 附录：关键代码
```python
import numpy as np
import matplotlib.pyplot as plt

def analyze_harmonic_series(max_exp=8, num_points=50):
    N_values = np.logspace(1, max_exp, num_points).astype(int)
    diffs = []
    
    for N in N_values:
        s_up = sum_up(N)
        s_down = sum_down(N)
        diff = relative_diff(s_up, s_down)
        diffs.append(diff)
    
    plt.loglog(N_values, diffs, 'o-')
    plt.xlabel('N')
    plt.ylabel('Relative Difference')
    plt.title('Effect of Summation Order on Precision')
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    analyze_harmonic_series()
```
