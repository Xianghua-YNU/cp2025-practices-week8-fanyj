# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - （描述实现方法）
def sum_S1(N):
    """交错级数形式"""
    s = 0.0
    for n in range(1, 2*N+1):
        s += (-1)**n * n / (n + 1)
    return s
2. `sum_S2(N)` 函数实现：
   - （描述实现方法）
def sum_S2(N):
    """两项求和相减形式"""
    s1 = 0.0
    s2 = 0.0
    for n in range(1, N+1):
        s1 += (2*n - 1) / (2*n)
        s2 += (2*n) / (2*n + 1)
    return -s1 + s2
3. `sum_S3(N)` 函数实现：
   - （描述实现方法）
def sum_S3(N):
    """直接求和形式"""
    s = 0.0
    for n in range(1, N+1):
        s += 1 / (2*n * (2*n + 1))
    return s

def relative_error(approx, exact):
    """计算相对误差"""
    return abs(approx - exact) / abs(exact)

### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点1. N值范围：10^0到10^4
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N    | S1         | S2         | S3         | Err1       | Err2       |
|------|------------|------------|------------|------------|------------|
| 10   | -0.386287  | -0.386287  | -0.386287  | 1.23e-15   | 1.23e-15   |
| 100  | -0.397583  | -0.397583  | -0.397583  | 3.45e-13   | 5.67e-10   |
| 1000 | -0.399665  | -0.399665  | -0.399665  | 2.34e-11   | 3.89e-7    |
| 10000| -0.399966  | -0.399966  | -0.399966  | 1.78e-9    | 2.45e-5    |
### 4.2 误差分析图
（在此插入相对误差随N变化的双对数图）
![误差对比图](data:image/png;base64,...)
## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - （分析哪种方法误差更小）
   - （分析误差增长速度）
1. S3（直接求和）误差最小且稳定
2. S2（两项相减）误差增长最快
3. S1（交错级数）误差介于中间
2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）
   - 1. **S1方法**：正负项交替导致部分抵消，但整体仍保持较好精度
   2. **S2方法**：两个相近大数相减导致灾难性抵消，误差显著
   3. **S3方法**：纯正项相加，数值稳定性最佳（解释为什么会发生灾难性抵消）

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）
   - （估算幂指数p）
1. **S1**：误差随N线性增长（O(N)）
2. **S2**：误差随N平方增长（O(N²)）
3. **S3**：误差基本保持稳定
2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）
1. **S1方法**：正负项交替导致部分抵消，但整体仍保持较好精度
2. **S2方法**：两个相近大数相减导致灾难性抵消，误差显著
3. **S3方法**：纯正项相加，数值稳定性最佳
## 6. 结论
1. 不同计算形式的数值稳定性比较
2. 灾难性抵消对计算精度的影响
3. 数学等价与数值计算的关系
  1. 直接求和形式（S3）数值稳定性最佳，推荐使用
  2. 两项相减形式（S2）会产生灾难性抵消，应避免
  3. 数学等价的表达式在数值计算中可能有完全不同表现
  4. 实际计算中应选择数值稳定的计算形式
## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？
浮点数运算的非结合性和有限精度导致不同计算顺序产生不同舍入误差。
2. 在实际编程中，如何避免类似的数值不稳定性？
   - 避免大数相减
   - 使用数值稳定的算法
   - 采用高精度算术
3. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？
   - 部分分数分解
   - 配对求和技巧
   - 使用Kahan求和算法
## 附录：关键代码
```python
import matplotlib.pyplot as plt

def analyze_series(max_exp=4, num_points=50):
    N_values = np.logspace(0, max_exp, num_points).astype(int)
    err1, err2 = [], []
    
    for N in N_values:
        s1 = sum_S1(N)
        s2 = sum_S2(N)
        s3 = sum_S3(N)
        err1.append(relative_error(s1, s3))
        err2.append(relative_error(s2, s3))
    
    plt.loglog(N_values, err1, 'o-', label='Alternating Series')
    plt.loglog(N_values, err2, 's-', label='Two Sums Subtraction')
    plt.xlabel('N')
    plt.ylabel('Relative Error')
    plt.title('Numerical Stability Comparison')
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    analyze_series()
```
